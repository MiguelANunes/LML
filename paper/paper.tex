%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation emai}{June 03--05,
  2018}{Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{minted}
\usepackage{bussproof}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}
%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Towards a Sound and Complete Library for Modal Logics Reasoning in Coq}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ariel Agne da Silveira}
\author{Miguel}
\author{Paulo Torrens}
\author{Karina Roggia}
\author{Rodrigo Ribeiro}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{da Silveira et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  The correct specification of requirements is crucial for software development.
  Modal logics are ...
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Modal logics, soundness, completeness, Coq proof assistant}

\maketitle

\section{Introduction}\label{sec:intro}

Our society depends heavily on computing technology: our cars, airplanes, medical devices
and banking applications all rely on software artifacts. In this scenario,
\emph{formal methods} play a crucial role to ensure that a program follows its
specification, thus avoiding failures which can cause castrophic outcomes. Interactive
proof assistants, like Coq~\cite{manual_coq} and Isabelle/HOL~\cite{manual_isabelle}, can
be used to verify software components and have been applied with success in
non-trivial projects like a certified compiler for C programming
language~\cite{Leroy09} and the kernel of seL4 operating system~\cite{Klein10}.

Usually, complex software systems are formed by various inter-communicating
components. A key aspect of the design of such programs is how to ensure that
a failure of a single component does not compromise the whole system.
The main difficulty is such formalization tasks is how to guarantee correct
error detection and that its corresponding fix will ensure that the software
still continue to work under abnormal conditions. One way to express such
requirements is using \emph{modal logics}, which can specify communication
patterns and knowledge in software agents~\cite{Huth_Ryan}.

While modal logics allow the modelling of such requirements, proving properties
about them may be a hard task without proper tool support. There are some
dedicated provers for modal logics~\cite{Gleissner17,Mora11}, but we believe
that using mature tools, like a proof assistant, are a better option for
verifying facts using modal logics. We justify this choice by: 1) the recent
successful histories on verification of software and
mathematics~\cite{Leroy09,Klein10,Gonthier13,Gonthier08}; 2) There is a growing
community of developers using such tools thanks to 
textbooks on the subject~\cite{Nipkow14,Bertot10,Chlipala13} which allows
newbies to join the game of formal verification and 3) The custom automation
facilities supported by current proof assistants allows that trivial facts can
be proved using decision procedures, relieving the user from writing proof
scripts for formulas that can be checked automatically.

In this context, the present work aims to contribute by constructing a library
that formalize a family of modal logics and its related properties in Coq.
By using such a library, a developer could use all Coq's resources to prove
modal logics facts.

More specifically, we contribute:

\begin{itemize}
  \item We define a \emph{deep embedding} of modal logic syntax in Coq and
    define its Kripke semantics.
  \item We model the Hilbert deductive systems as a Coq inductive type that is
    parameterized by different axiom systems like K, D, B, T, K4, K5, S4 and S5
    and prove its soundness with respect to Kripke semantics. We also
    discuss the current status of the formalization of the completeness result.
  \item We show a proof of the L\"ob's theorem using the Hilbert deductive system
    developed in our library.
\end{itemize}

The rest of this work is organized as follows: Section~\ref{sec:background} provides
brief introduction on modal logics and the Coq proof assistant. Details about
the implementation of our Coq library are presented in
Section~\ref{sec:implementation}. A case study in proving the L\"ob's theorem is
the subject of Section~\ref{sec:case}. Related work is discussed
on Section~\ref{sec:related} and Section~\ref{sec:conclusion} draws some conclusions and
provide some pointers for future works.

\section{Background}\label{sec:background}

\paragraph{An overview of Coq proof assistant.}

Coq is a proof assistant based on the calculus of inductive
constructions (CIC)~\cite{manual_cic}, a higher order typed
$\lambda$-calculus extended with inductive definitions.  Theorem
proving in Coq follows the ideas of the so-called
``BHK-cor\-res\-pon\-dence''\footnote{Abbreviation of Brouwer, Heyting,
  Kolmogorov, de Bruijn and Martin-L\"of Correspondence. This is also
  known as the Curry-Howard ``isomorphism''.}, where types represent
logical formulas, $\lambda$-terms represent proofs
\cite{Bertot10} and the task of checking if a piece of text is a
proof of a given formula corresponds to checking if the term that
represents the proof has the type corresponding to the given formula.

However, writing a proof term whose type is that of a logical formula
can be a hard task, even for very simple propositions.  In order to
make the writing of complex proofs easier, Coq provides
\emph{tactics}, which are commands that can be used to construct proof
terms in a more user friendly way.

As a tiny example, consider the task of proving the following simple
formula of propositional logic:
\[
(A \to B)\to (B\to C) \to A \to C
\]
In Coq, such theorem can be expressed as:
\begin{minted}{coq}
Section EXAMPLE.
   Variables A B C : Prop.
   Theorem example : (A -> B) -> (B -> C) -> A -> C.
   Proof.
       intros H H' HA. apply H'. apply H. assumption. 
   Qed.
End EXAMPLE.
\end{minted}
In the previous source code piece, we have defined a Coq section named
\mintinline{coq}{EXAMPLE}\footnote{In Coq, we can use sections to delimit the
  scope of local variables.} which declares variables \mintinline{coq}{A},
\mintinline{coq}{B} and \mintinline{coq}{C} as being propositions (i.e. with type
\mintinline{coq}{Prop}). Tactic \mintinline{coq}{intros} introduces variables
\mintinline{coq}{H}, \mintinline{coq}{H'} and \mintinline{coq}{HA} into the (typing) context,
respectively with types \mintinline{coq}{A -> B}, \mintinline{coq}{B -> C} and
\mintinline{coq}{A} and leaves goal \mintinline{coq}{C} to be proved. Tactic
\mintinline{coq}{apply}, used with a term \mintinline{coq}{t}, generates goal
\mintinline{coq}{P}
when there exists \mintinline{coq}{t: P -> Q} in the typing context and the
current goal is \mintinline{coq}{Q}. Thus, \mintinline{coq}{apply H'} changes the goal
from \mintinline{coq}{C} to \mintinline{coq}{B} and \mintinline{coq}{apply H}
changes the goal to \mintinline{coq}{A}. Tactic \mintinline{coq}{assumption}
traverses the typing context to find a hypothesis that matches the goal.

We define next a proof of the previous propositional logical formula
that, in contrast to the previous proof, that was built using tactics
(\mintinline{coq}{intros}, \mintinline{coq}{apply} and \mintinline{coq}{assumption}), is coded
directly as a function:
\begin{minted}{coq}
Definition example :(A -> B) -> (B -> C) -> A -> C :=
 fun (H : A -> B)
     (H' : B -> C)
     (HA : A) => H' (H HA).
\end{minted}
However, even for very simple theorems, coding a definition directly
as a Coq term can be a hard task. Because of this, the use of tactics
has become the standard way of proving theorems in Coq. Furthermore,
the Coq proof assistant provides not only a great number of tactics
but also a domain specific language for scripted proof automation,
called $\mathcal{L}$tac. Details about $\mathcal{L}$tac and Coq can be found
in~\cite{Chlipala13,Bertot10,manual_coq}.

\paragraph{An overview of modal logic.} Modal logics are designed for reasoning
about truth across various --- abstract --- worlds. In such logics, a
proposition may be true in some world, but false in another one. The versions of
modal logics considered in this work extends traditional propositional logics
with two operators on propositions: $\Box$ (box) and $\Diamond$ (diamond).
The syntax of modal logic formulas are defined by the following context free
grammar (where $\circ \in\{\land,\lor,\to,\leftrightarrow\}$ and
$\mathcal{P} = \{A,B,C,...\}$ is the enumerable set of propositional variables):
\[
  \begin{array}{lcl}
    \varphi & ::= & \bot\,|\,\top\,|\,A\,|\,\neg\varphi\,|\,\varphi\circ\varphi\,|\,\Box\varphi\,|\,\Diamond\varphi
  \end{array}  
\]
Intuitively, the semantics of the operator $\Box$ is similar to an universal
quantifier, since it express \emph{necessity}: $\Box\,\varphi$ is true at the
current world iff $\varphi$ is true at all worlds. Similarly, the semantics of operator
$\Diamond$ is that a formula $\Diamond\varphi$ is true at the current
world iff $\varphi$ is \emph{possible}, i.e. true in at least some world.

Formally, we can only interpret a formula with respect to a \emph{model}, which is
defined as follows.
A \emph{frame} $\mathcal{F} = \langle W, R \rangle$ consists of a pair formed by
a non-empty set of worlds, $W$, and a binary accessibility relation between
worlds, $R \subseteq W \times W$. A pair $w_1Rw_2$ denotes that world $w_2$ is
accessible from $w_1$. A model $\mathcal{M} = \langle \mathcal{F}, \mathcal{V} \rangle$
is formed by a frame $\mathcal{F}$ and a total labeling function
$\mathcal{V} : \mathcal{P}\times W\to \{F,T\}$, which assigns
a truth value to a propositional variable at a given world, i.e. when $w \in \mathcal{V}(A)$
for some $A \in\mathcal{P}$, we say that $A$ holds in $w$. The satisfiability of a formula
in a given world is defined by inductive relation $\mathcal{M}\,;\,w\models \varphi$ as
follows (notation $\mathcal{M}\,;\,w\not\models \varphi$ denotes
that $\mathcal{M}\,;\,w\models \varphi$ does not hold):

\begin{figure}[H]
\begin{enumerate}
  \item $\mathcal{M}\,;\,w\not\models \bot$ and $\mathcal{M}\,;\,w\models \top$;
  \item $\mathcal{M}\,;\,w\models A$ iff $\mathcal{V}(A,w) = T$;
  \item $\mathcal{M}\,;\,w\models \neg\varphi$ iff $\mathcal{M}\,;\,w\not\models\varphi$;
  \item $\mathcal{M}\,;\,w\models \varphi_1 \land \varphi_2$ iff
    $\mathcal{M}\,;\,w\models\varphi_1$ and $\mathcal{M}\,;\,w\models\varphi_2$;
  \item $\mathcal{M}\,;\,w\models \varphi_1 \lor \varphi_2$ iff
    $\mathcal{M}\,;\,w\models\varphi_1$ or $\mathcal{M}\,;\,w\models\varphi_2$;
  \item $\mathcal{M}\,;\,w\models \varphi_1 \to \varphi_2$ iff
    $\mathcal{M}\,;\,w\not\models\varphi_1$ or $\mathcal{M}\,;\,w\models\varphi_2$;
  \item $\mathcal{M}\,;\,w\models\Box\varphi$ iff $\forall w \in W. w R y \to \mathcal{M}\,;\,y \models\varphi$;
  \item $\mathcal{M}\,;\,w\models\Diamond\varphi$ iff $\exists w \in W. w R y \land \mathcal{M}\,;\,y \models\varphi$;
  \end{enumerate}
  \caption{Kripke semantics}
  \label{fig:kripke}
\end{figure}
We say that a formula $\varphi$ is satisfiable in a model $\mathcal{M}$,
denoted by $\mathcal{M}\models \varphi$, if $\forall w \in W. M\,;w\,\models \varphi$ holds.
Similarly, $\varphi$ is valid in a frame $\mathcal{F}$, written $\mathcal{F}\models\varphi$, if
it holds on all models $\mathcal{M} = \langle \mathcal{F},\mathcal{V}\rangle$, i.e.
for any $\mathcal{M}$, we have that $\mathcal{M}\models\varphi$. A formula
is valid, written $\models \varphi$, if it is valid in any frame $\mathcal{F}$.

Using the semantics, we can define the concept of \emph{entailment}: Given a set
of formulas $\Gamma$ and a formula $\varphi$, we say that $\Gamma$ entails
$\varphi$, written $\Gamma\models\varphi$, iff $\forall \varphi' \in\Gamma .
\mathcal{M} \models \varphi' \to \mathcal{M} \models \varphi$, for some model $\mathcal{M}$.

In this work, we consider Hilbert deductive systems for modal logics.
Essentially, the considered system adds axioms for the modalities
to the set of axioms for classical propositional logic.
The most basic axiom is \textbf{K} which express that $\Box$ distributes
over implication. Axiom of possibility states that $\Diamond$ distributes
over disjunction.
\[
  \begin{array}{ll}
    \textbf{K}           & \Box(A \to B) \to (\Box A \to \Box B)\\
    \textbf{Possibility} & \Diamond (A \lor B) \to (\Diamond A \lor \Diamond B)\\
  \end{array}
\]
Apart from the axioms, we also need the traditional \emph{modus ponens} rule
and a rule that allows to conclude formulas with necessity. 

\begin{figure}[H]
\begin{tabular}{cc}
    \AxiomC{$\Gamma\vdash\varphi_1\to\varphi_2$}
    \AxiomC{$\Gamma\vdash\varphi_1$}
    \RightLabel{MP}
    \BinaryInfC{$\Gamma\vdash\varphi_2$}
    \DisplayProof
  &
    \AxiomC{$\Gamma\vdash\varphi$}
    \RightLabel{Nec}
    \UnaryInfC{$\Gamma\vdash\Box \varphi$}
    \DisplayProof
\end{tabular}
\end{figure}
The set of axioms and the two previous rules forms a sound and complete Hilbert-style
deductive system for modal logics~\cite{blackburn}.

A central aspect in the study of modal logics is the so-called \emph{frame
  correspondence}, which is a relationship between the
accessibility relation and the truth of certain formulas in frames containing
it. As an example, consider a frame $\mathcal{F} = \langle W,R
\rangle$ in which the relation $R$ is reflexive: $\forall w \in W. wRw$, i.e.
every world is accessible from itself. In such frame when $\Box A$ holds at
a world $w$, $w$ itself is among the accessible worlds at which $A$ must be true.
In this way, if the accessibility relation $R$ is reflexive, then whatever world
$w$ and formula $\varphi$ we take, the formula $\Box \varphi \to \varphi$ will
be true there. Example of properties that characterize certain formula schemas are
presented in the table below.

\begin{figure}[H]
\begin{tabular}{|c|c|}
  \hline
  Property of $R$                          & Formula schema \\ \hline
  reflexive: $\forall w.wRw$               & $\Box A \to A$ \\ 
  serial: $\forall w\exists w'. wRw'$      & $\Box A \to \Diamond A$ \\
  symmetric: $\forall w\,w'.wRw' \to w'Rw$ & $A \to \Box\Diamond A$ \\
  \hline
\end{tabular}
\end{figure}
There are other properties of interest for a relation $R$ like being
transitive, functional, euclidean, and so on. More about the correspondence
of frames and deductive systems properties can be found elsewhere~\cite{Chellas,blackburn}.

\section{Embedding Modal Logic in Coq}\label{sec:implementation}

In this section, we describe the implementation details of our modal logic
library in Coq. We start by describing the structure of formula syntax and the
representation of frames and models, needed to define the Kripke semantics.
Next, we define a modular Hilbert-style deductive system. The modularization is
obtained by parameterizing it by a set of axioms used. This allow us to
generalize results about derivations to several deductive systems, independently
of the axioms used. We conclude by discussing the soundness, the current
status of the completeness and the frame correspondence proofs.

\paragraph{Syntax and semantics of modal logics}
In order to implement our library, we use a \emph{deep embedding} of
formulas, i.e. we represent formulas as the following Coq inductive datatype.
\begin{minted}{coq}
Inductive form : Set :=
| Lit     : nat          -> form
| Neg     : form -> form
| Box     : form -> form
| Dia     : form -> form
| And     : form -> form -> form
| Or      : form -> form -> form
| Implies : form -> form -> form.
\end{minted}
Most constructors of the type have an immediate meaning, since they represent
connectives of propositional logics. The constructor \mintinline{coq}{Lit}
is used to construct propositional variables; constructor \mintinline{coq}{Box}
denotes the modal operator $\Box$ and \mintinline{coq}{Dia}, the operator
$\Diamond$.

Before defining the Kripke semantics, we need to represent the model used to
interpret a modal logic formula. We encode a frame by a record formed by a
a type \mintinline{coq}{W : Set} to represent the set of worlds and the
accessibility relation is denoted by a type \mintinline{coq}{R : W -> W -> Prop}.
\begin{minted}{coq}
Record Frame : Type := {
  W : Set;
  R : W -> W -> Prop;
}.
\end{minted}
A model is denoted by another record formed by a frame and a labelling function,
which assign the truth value of a variable at a given world.
\begin{minted}{coq}
Record Model : Type := {
  F : Frame; 
  v : nat -> (W F) -> Prop; 
}.
\end{minted}
Note that the type of the labelling function \mintinline{coq}{v} ensures that it
refers to a world from the set of possible worlds in the frame
\mintinline{coq}{F}. The encoding of the Kripke semantics is done by a Coq function
that which implements the relation of Figure~\ref{fig:kripke}. We omit the code
for propositional logics connectives for brevity. The interesting parts are for
variables (constructor \mintinline{coq}{Lit}) which uses the labelling function
\mintinline{coq}{v} from the model \mintinline{coq}{M}. The meaning of
modalities $\Box$ and $\Diamond$ are represented by a quantifying over worlds
using the accessibility relation $R$. 
\begin{minted}{coq}
Fixpoint formula_valuation (M: Model)
                           (w: W (F M))
                           (phi: form): Prop :=
  match phi with
  | Lit     x            => v M x w 
  | Box     psi
     => forall w': W (F M), R (F M) w w' ->
                            formula_valuation M w' psi
  | Dia     psi
     => exists w': W (F M), R (F M) w w' /\
                   formula_valuation M w' psi
  (** some code omitted *)
  end.
\end{minted}
In order to ease the task of writing formulas and its semantics properties, we
define Coq notations that mimics the standard way of writing them.

\paragraph{The Hilbert deductive system}
Basically, a Hilbert-style deductive system allows the use of on four
possibilities in a proof: 1) the use of a hypothesis; 2) use of an axiom;
3) use of the modus ponens rule or 4) the use of the generalization (necessity)
rule. The inductive type \mintinline{coq}{deduction} encodes these possibilities
as its constructors. The \mintinline{coq}{deduction} type is parameterized by
axioms that form a system for modal logics. In this way, our definition can be
used by several systems of modal logic.
\begin{minted}{coq}
Inductive deduction (A: axiom -> Prop)
                           : theory -> form -> Prop :=
  (* Premise. *)
  | Prem: forall (t: theory)
                 (f: form)
                 (i: nat),
          (nth_error t i = Some f) -> deduction A t f
  (* Axiom. *)
  | Ax: forall (t: theory)
               (a: axiom)
               (f: form),
        A a -> instantiate a = f -> deduction A t f
  (* Modus Ponens. *)
  | Mp: forall (t: theory)
               (f g: form)
               (d1: deduction A t (f -> g))
               (d2: deduction A t f),
        deduction A t g
  (* Generalization. *)
  | Nec: forall (t: theory)
                (f: form)
                (d1: deduction A t f),
         deduction A t (Box f).
\end{minted}
The constructors \mintinline{coq}{Prem}, \mintinline{coq}{Mp} and \mintinline{coq}{Nec}
represent rules for hypothesis, modus ponens and generalization, respectively.
Before discuss the rule for axioms, we need to discuss how axioms are
represented in our library. The inductive type \mintinline{coq}{axiom} specifies
the different axioms supported by our library.
\begin{minted}{coq}
Inductive axiom : Set :=
  | ax1   : modalFormula -> modalFormula -> axiom
  | ax2   : modalFormula -> modalFormula ->
                            modalFormula -> axiom
  (** some code omitted *)
  | axK   : modalFormula -> modalFormula -> axiom
  | axPos : modalFormula -> modalFormula -> axiom
  | axT   : modalFormula -> axiom
  | axB   : modalFormula -> axiom
  | axK4  : modalFormula -> axiom
  | axD   : modalFormula -> axiom
  | axK5  : modalFormula -> axiom.
\end{minted}
Each constructor of type \mintinline{coq}{axiom} represents an axiom and
its type stores the subformulas which compose the axiom. The type has
17 constructors: the first 10 consists encode axioms for propositional logics
and the last 7 are for different formulas taken as axioms by systems of modal logics.
Axioms are built using the function \mintinline{coq}{instantiate}, which
receives an axiom and build its corresponding formula by pattern matching as
follows:
\begin{minted}{coq}
Definition instantiate (a: axiom): modalFormula :=
  match a with
  | ax1    p   q
     => [! p -> (q -> p) !]
  | ax2    p   q   r
     => [! (p -> (q -> r)) -> ((p -> q) -> (p -> r)) !]
  | ax3    p   q
     => [! (~ q -> ~ p) -> (p -> q) !]
  | axK    p   q
     => [! [] (p -> q) -> ([] p -> [] q) !]
  | axPos  p   q
     => [! <> (p \/ q) -> (<> p \/ <> q) !]
  (** some code omitted *)
  end.
\end{minted}
Notation \mintinline{coq}{[! p !]} is used to write modal logic formulas using a
syntax closer to mathematical practice using Coq. This is necessary to avoid
parsing ambiguities, since some symbols are also used by Coq's syntax.
Modalities $\Box$ and $\Diamond$ are denoted by \mintinline{coq}{[]}
and \mintinline{coq}{<>}, respectively.

The \mintinline{coq}{Ax} constructor uses the \mintinline{coq}{instantiate} to
create a formula instance from using a given system, represented as a predicate
\mintinline{coq}{A : axiom -> Prop}, which parameterizes our deduction type. An
axiom \mintinline{coq}{a} is valid within a system \mintinline{coq}{A} whenever
the type \mintinline{coq}{A a} is inhabited, i.e. it is not empty. Next, we
detail the representation of different systems of modal logic in our library.

\paragraph{Systems of modal logics} In order to use the deductive system to
check the provability of formulas, we need to specify the axioms that are
included in the system. Our approach is we represent to define predicates
which denote each system. The simplest set of axioms is usually refereed as
\textbf{K} and it includes the axiom $\Box(A \to B) \to (\Box A \to \Box B)$
and all the axioms for propositional logic. We represent system \textbf{K}
by the following inductive type:
\begin{minted}{coq}
Inductive K: axiom -> Prop :=
  | K_ax1: forall p q, K (ax1 p q)
  | K_ax2: forall p q r, K (ax2 p q r)
  (** some code omitted *)
  | K_axK: forall p q, K (axK p q)
\end{minted}


\paragraph{Properties}


\section{Case Study}\label{sec:case}

\section{Related work}\label{sec:related}

\paragraph{Formalizations of modal logics on proof assistants}

The formalization of epistemic modal logic in Coq was the subject of Wind's
work~\cite{dewind}.
The author made a Coq implementation of modal logic based on the S5 system,
which consists of  the axioms $K$, $T$, $4$ and $5$. The objective was the
modelling of two well known puzzles.
Wind's formalization was separated into some components. The first consists in
defining the syntax of formulas and the Kripke semantics. Next, the author uses
their definitions to give some examples of modal operators, worlds and how they
interact with each other. Using the built machinery, the author developed
introduction and elimination rules for modal logic and use them to model the
wize man's and muddy children puzzles.


\section{Conclusion}\label{sec:conclusion}



\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}