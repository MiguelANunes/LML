%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation emai}{June 03--05,
  2018}{Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\usepackage{minted}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}
%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Towards a Sound and Complete Library for Modal Logics Reasoning in Coq}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ariel Agne da Silveira}
\author{Paulo Torrens}
\author{Karina Roggia}
\author{Rodrigo Ribeiro}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{da Silveira et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  The correct specification of requirements is crucial for software development.
  Modal logics are ...
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Modal logics, soundness, completeness, Coq proof assistant}

\maketitle

\section{Introduction}\label{sec:intro}

Our society depends heavily on computing technology: our cars, airplanes, medical devices
and banking applications all rely on software artifacts. In this scenario,
\emph{formal methods} play a crucial role to ensure that a program follows its
specification, thus avoiding failures which can cause castrophic outcomes. Interactive
proof assistants, like Coq~\cite{manual_coq} and Isabelle/HOL~\cite{manual_isabelle}, can
be used to verify software components and have been applied with success in
non-trivial projects like a certified compiler for C programming
language~\cite{Leroy09} and the kernel of seL4 operating system~\cite{Klein10}.

Usually, complex software systems are formed by various inter-communicating
components. A key aspect of the design of such programs is how to ensure that
a failure of a single component does not compromise the whole system.
The main difficulty is such formalization tasks is how to guarantee correct
error detection and that its corresponding fix will ensure that the software
sill continue to work under abnormal conditions. One way to express such
requirements is using \emph{modal logics}, which can specify communication
patterns and knowledge in software agents~\cite{Huth_Ryan}.

While modal logics allow the modelling of such requirements, proving properties
about them may be a hard task without proper tool support. There are some
dedicated provers for modal logics~\cite{Gleissner17,Mora11}, but we believe
that using mature tools, like a proof assistant, are a better option, for
verifying facts using modal logics. We justify this choice by: 1) the recent
successful histories on verification of software and
mathematics~\cite{Leroy09,Klein10,Gonthier13,Gonthier08}; 2) There is a growing
community of developers using such tools thanks to 
textbooks on the subject~\cite{Nipkow14,Bertot10,Chlipala13} which allows
newbies to join the game of formal verification and 3) The custom automation
facilities that current proof assistants support allows that some trivial facts can
be checked using decision procedures.

In this context, the present work aims to contribute by constructing a library
that formalize a family of modal logics and its related properties in Coq.
By using such a library, a developer could use all Coq's resources to prove
modal logics facts.

More specifically, we contribute:

\begin{itemize}
  \item We define a \emph{deep embedding} of modal logic syntax in Coq and
    define its Kripke semantics.
  \item We model the Hilbert deductive systems K, D, B, T, K4, K5, S4 and S5
    in Coq and prove its soundness with respect to Kripke semantics.
  \item We show a proof of the L\"ob's theorem using the Hilbert deductive system
    developed in our library.
\end{itemize}

The rest of this work is organized as follows: Section~\ref{sec:background} provides
brief introduction on modal logics and the Coq proof assistant. Details about
the implementation of our Coq library are presented in
Section~\ref{sec:implementation}. A case study in proving the L\"ob's theorem is
the subject of Section~\ref{sec:case}. Related work is discussed
on Section~\ref{sec:related} and Section~\ref{sec:conclusion} draws some conclusions and
provide some pointers for future works.

\section{Background}\label{sec:background}

\paragraph{An overview of Coq proof assistant.}

Coq is a proof assistant based on the calculus of inductive
constructions (CIC)~\cite{manual_cic}, a higher order typed
$\lambda$-calculus extended with inductive definitions.  Theorem
proving in Coq follows the ideas of the so-called
``BHK-cor\-res\-pon\-dence''\footnote{Abbreviation of Brouwer, Heyting,
  Kolmogorov, de Bruijn and Martin-L\"of Correspondence. This is also
  known as the Curry-Howard ``isomorphism''.}, where types represent
logical formulas, $\lambda$-terms represent proofs
\cite{Bertot10} and the task of checking if a piece of text is a
proof of a given formula corresponds to checking if the term that
represents the proof has the type corresponding to the given formula.

However, writing a proof term whose type is that of a logical formula
can be a hard task, even for very simple propositions.  In order to
make the writing of complex proofs easier, Coq provides
\emph{tactics}, which are commands that can be used to construct proof
terms in a more user friendly way.

As a tiny example, consider the task of proving the following simple
formula of propositional logic:
\[
(A \to B)\to (B\to C) \to A \to C
\]
In Coq, such theorem can be expressed as:
\begin{minted}{coq}
Section EXAMPLE.
   Variables A B C : Prop.
   Theorem example : (A -> B) -> (B -> C) -> A -> C.
   Proof.
       intros H H' HA. apply H'. apply H. assumption. 
   Qed.
End EXAMPLE.
\end{minted}
In the previous source code piece, we have defined a Coq section named
\mintinline{coq}{EXAMPLE}\footnote{In Coq, we can use sections to delimit the
  scope of local variables.} which declares variables \mintinline{coq}{A},
\mintinline{coq}{B} and \mintinline{coq}{C} as being propositions (i.e. with type
\mintinline{coq}{Prop}). Tactic \mintinline{coq}{intros} introduces variables
\mintinline{coq}{H}, \mintinline{coq}{H'} and \mintinline{coq}{HA} into the (typing) context,
respectively with types \mintinline{coq}{A -> B}, \mintinline{coq}{B -> C} and
\mintinline{coq}{A} and leaves goal \mintinline{coq}{C} to be proved. Tactic
\mintinline{coq}{apply}, used with a term \mintinline{coq}{t}, generates goal
\mintinline{coq}{P}
when there exists \mintinline{coq}{t: P -> Q} in the typing context and the
current goal is \mintinline{coq}{Q}. Thus, \mintinline{coq}{apply H'} changes the goal
from \mintinline{coq}{C} to \mintinline{coq}{B} and \mintinline{coq}{apply H}
changes the goal to \mintinline{coq}{A}. Tactic \mintinline{coq}{assumption}
traverses the typing context to find a hypothesis that matches with the goal.

We define next a proof of the previous propositional logical formula
that, in contrast to the previous proof, that was built using tactics
(\mintinline{coq}{intros}, \mintinline{coq}{apply} and \mintinline{coq}{assumption}), is coded
directly as a function:
\begin{minted}{coq}
Definition example :(A -> B) -> (B -> C) -> A -> C :=
 fun (H : A -> B)
     (H' : B -> C)
     (HA : A) => H' (H HA).
\end{minted}
However, even for very simple theorems, coding a definition directly
as a Coq term can be a hard task. Because of this, the use of tactics
has become the standard way of proving theorems in Coq. Furthermore,
the Coq proof assistant provides not only a great number of tactics
but also a domain specific language for scripted proof automation,
called $\mathcal{L}$tac. Details about $\mathcal{L}$tac and Coq can be found
in~\cite{Chlipala13,Bertot10,manual_coq}.

\paragraph{An overview of modal logic.} Modal logics are designed for reasoning
about truth across various --- abstract --- worlds. In such logics, a
proposition may be true in some world, but false in another one. The versions of
modal logics considered in this work extends traditional propositional logics
with two operators on propositions: $\Box$ (box) and $\Diamond$ (diamond).
The syntax of modal logic formulas are defined by the following context free
grammar (where $\circ \in\{\land,\lor,\to,\leftrightarrow\}$, $\mathcal{P}$ is
the enumerable set of propositional variables and $A\in\mathcal{P}$ is arbitrary):
\[
  \begin{array}{lcl}
    \varphi & ::= & \bot\,|\,\top\,|\,A\,|\,\neg\varphi\,|\,\varphi\circ\varphi\,|\,\Box\varphi\,|\,\Diamond\varphi
  \end{array}  
\]
Intuitively, the semantics of the operator $\Box$ is similar to an universal
quantifier, since it express \emph{necessity}: $\Box\,\varphi$ is true at the
current world iff $\varphi$ is true at all worlds. Similarly, the semantics of operator
$\Diamond$ is that a formula $\Diamond\varphi$ is true at the current
world iff $\varphi$ is \emph{possible}, i.e. true in at least some world.

Formally, we can only interpret a formula with respect to a \emph{model}, which is
defined as follows.
A \emph{frame} $\mathcal{F} = \langle W, R \rangle$ consists of a pair formed by
a non-empty set of worlds, $W$, and a binary accessibility relation between
worlds, $R \subseteq W \times W$. A pair $w_1Rw_2$ denotes that world $w_2$ is
accessible from $w_1$. A model $\mathcal{M} = \langle \mathcal{F}, \mathcal{V} \rangle$
of a frame $\mathcal{F}$ and a total labeling function
$\mathcal{V} : \mathcal{P}\times W\to \{F,T\}$, which assigns
a truth value to a propositional variable at a given world, i.e. when $w \in \mathcal{V}(A)$
for some $A \in\mathcal{P}$, we say that $A$ holds in $w$. The satisfiability of a formula
in a given world is defined by inductive relation $\mathcal{M}\,;\,w\models \varphi$ as
follows (notation $\mathcal{M}\,;\,w\not\models \varphi$ denotes
that $\mathcal{M}\,;\,w\models \varphi$ does not hold):

\begin{enumerate}
  \item $\mathcal{M}\,;\,w\not\models \bot$ and $\mathcal{M}\,;\,w\models \top$;
  \item $\mathcal{M}\,;\,w\models A$ iff $\mathcal{V}(A,w) = T$;
  \item $\mathcal{M}\,;\,w\models \neg\varphi$ iff $\mathcal{M}\,;\,w\not\models\varphi$;
  \item $\mathcal{M}\,;\,w\models \varphi_1 \land \varphi_2$ iff
    $\mathcal{M}\,;\,w\models\varphi_1$ and $\mathcal{M}\,;\,w\models\varphi_2$;
  \item $\mathcal{M}\,;\,w\models \varphi_1 \lor \varphi_2$ iff
    $\mathcal{M}\,;\,w\models\varphi_1$ or $\mathcal{M}\,;\,w\models\varphi_2$;
  \item $\mathcal{M}\,;\,w\models \varphi_1 \to \varphi_2$ iff
    $\mathcal{M}\,;\,w\not\models\varphi_1$ or $\mathcal{M}\,;\,w\models\varphi_2$;
  \item $\mathcal{M}\,;\,w\models\Box\varphi$ iff $\forall w \in W. w R y \to \mathcal{M}\,;\,y \models\varphi$;
  \item $\mathcal{M}\,;\,w\models\Diamond\varphi$ iff $\exists w \in W. w R y \land \mathcal{M}\,;\,y \models\varphi$;
\end{enumerate}  

We say that a formula $\varphi$ is satisfiable in a model $\mathcal{M}$,
denoted by $\mathcal{M}\models \varphi$, if $\forall w \in W. M\,;w\,\models \varphi$ holds.
Similarly, $\varphi$ is valid in a frame $\mathcal{F}$, written $\mathcal{F}\models\varphi$, if
it holds on all models $\mathcal{M} = \langle \mathcal{F},\mathcal{V}\rangle$, i.e.
for any $\mathcal{M}$, we have that $\mathcal{M}\models\varphi$. Finally, we say that a formula
is valid, written $\models \varphi$, if it is valid in any frame $\mathcal{F}$.

\section{Embedding Modal Logic in Coq}\label{sec:implementation}

In this section, we describe the implementation details of our modal logic
library in Coq. We start by describing the structure of formula syntax and the
representation of frames and models, needed to define the Kripke semantics.

\paragraph{Syntax of modal logics formulas}
In order to implement our modal logic library, we use a \emph{deep embedding} of
formulas, i.e. we represent the syntax as the following Coq inductive datatype.
\begin{minted}{coq}
Inductive modalFormula : Set :=
| Lit     : nat          -> modalFormula
| Neg     : modalFormula -> modalFormula
| Box     : modalFormula -> modalFormula
| Dia     : modalFormula -> modalFormula
| And     : modalFormula -> modalFormula -> modalFormula
| Or      : modalFormula -> modalFormula -> modalFormula
| Implies : modalFormula -> modalFormula -> modalFormula.
\end{minted}
Most constructors of the type have an immediate meaning, since they represent
connectives of propositional logics. The constructor \mintinline{coq}{Lit}
is used to construct propositional variables; constructor \mintinline{coq}{Box}
denotes the modal operator $\Box$ and \mintinline{coq}{Dia}, the operator
$\Diamond$.

Before defining the Kripke semantics, we need to represent the model used to
interpret a modal logic formula. We encode a frame by a record formed by a
a type \mintinline{coq}{W : Set} to represent the set of worlds and the
accessibility relation \mintinline{coq}{R : W -> W -> Prop}.
\begin{minted}{coq}
Record Frame : Type := {
  W : Set;
  R : W -> W -> Prop;
}.
\end{minted}
A model is denoted by another record formed by a frame and a labelling function,
which assign the truth value of a variable at a given world.
\begin{minted}{coq}
Record Model : Type := {
  F : Frame; 
  v : nat -> (W F) -> Prop; 
}.
\end{minted}
Note that the type of the labelling function \mintinline{coq}{v} ensures that it
refers to a world from the set of possible worlds in the frame \mintinline{coq}{F}.

\section{Case Study}\label{sec:case}

\section{Related work}\label{sec:related}

\section{Conclusion}\label{sec:conclusion}



\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}